<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 15 章 先写注释 | 《软件设计的哲学》中文版</title>
    <meta name="description" content="软件设计的哲学 约翰·奥斯特豪特; A Philosophy of Software Design 中文翻译; 軟件設計的哲學 (第2版) 約翰·奧斯特豪特">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/A-Philosophy-of-Software-Design-zh/assets/style.Chy1hpNa.css" as="style">
    <link rel="preload stylesheet" href="/A-Philosophy-of-Software-Design-zh/vp-icons.css" as="style">
    
    <script type="module" src="/A-Philosophy-of-Software-Design-zh/assets/app.DVySZ4z5.js"></script>
    <link rel="preload" href="/A-Philosophy-of-Software-Design-zh/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/chunks/theme.pgRsb4MM.js">
    <link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/chunks/framework.Bt17Y4iU.js">
    <link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/ch15.md.cIjUFAql.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/A-Philosophy-of-Software-Design-zh/" data-v-1168a8e4><!--[--><!--]--><!----><span data-v-1168a8e4>《软件设计的哲学》中文版</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/A-Philosophy-of-Software-Design-zh/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>主页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/A-Philosophy-of-Software-Design-zh/ch01.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>章节正文</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/A-Philosophy-of-Software-Design-zh/summary.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>全书总结</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-8a42e2b4><button data-v-8a42e2b4>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 has-active" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>目录</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/preface.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>前言</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch01.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 1 章 介绍</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch02.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 2 章 复杂性的本质</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch03.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 3 章 工作代码是不够的</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch04.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 4 章 模块应该是深的</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch05.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 5 章 信息隐藏(和泄漏)</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch06.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 6 章 通用模块更深入</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch07.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 7 章 不同的层，不同的抽象</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch08.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 8 章 降低复杂性</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch09.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 9 章 在一起更好还是分开更好？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch10.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 10 章 定义不存在的错误</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch11.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 11 章 设计它两次</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch12.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 12 章 为什么要写注释呢？有四个理由</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch13.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 13 章 注释应该描述代码中不明显的内容</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch14.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 14 章 选择的名字</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch15.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 15 章 先写注释</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch16.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 16 章 修改现有的代码</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch17.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 17 章 一致性</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch18.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 18 章 代码应该是显而易见的</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch19.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 19 章 软件发展趋势</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch20.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 20 章 设计性能</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/ch21.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>第 21 章 结论</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/A-Philosophy-of-Software-Design-zh/summary.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>总结</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>On this page</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _A-Philosophy-of-Software-Design-zh_ch15" data-v-39a288b8><div><h1 id="第-15-章-先写注释" tabindex="-1">第 15 章 先写注释 <a class="header-anchor" href="#第-15-章-先写注释" aria-label="Permalink to &quot;第 15 章 先写注释&quot;">​</a></h1><blockquote><p>Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process)</p></blockquote><blockquote><p>Many developers put off writing documentation until the end of the development process, after coding and unit testing are complete. This is one of the surest ways to produce poor quality documentation. The best time to write comments is at the beginning of the process, as you write the code. Writing the comments first makes documentation part of the design process. Not only does this produce better documentation, but it also produces better designs and it makes the process of writing documentation more enjoyable.</p></blockquote><p>许多开发人员推迟编写文档，直到开发过程结束，编码和单元测试完成之后。这是产生质量差的文档的最可靠方法之一。编写注释的最佳时间是在过程开始时。首先编写注释使文档成为设计过程的一部分。这不仅可以产生更好的文档，还可以产生更好的设计，并使编写文档的过程更加愉快。</p><h2 id="_15-1-delayed-comments-are-bad-comments-迟到的注释不是好注释" tabindex="-1">15.1 Delayed comments are bad comments 迟到的注释不是好注释 <a class="header-anchor" href="#_15-1-delayed-comments-are-bad-comments-迟到的注释不是好注释" aria-label="Permalink to &quot;15.1 Delayed comments are bad comments 迟到的注释不是好注释&quot;">​</a></h2><blockquote><p>Almost every developer I have ever met puts off writing comments. When asked why they don’t write documentation earlier, they say that the code is still changing. If they write documentation early, they say, they’ll have to rewrite it when the code changes; better to wait until the code stabilizes. However, I suspect that there is also another reason, which is that they view documentation as drudge work; thus, they put it off as long as possible.</p></blockquote><p>我见过的几乎每个开发人员都会推迟编写注释。当被问及为什么不更早编写文档时，他们说代码仍在更改。他们说，如果他们尽早编写文档，则必须在代码更改时重新编写文档。最好等到代码稳定下来。但是，我怀疑还有另一个原因，那就是他们将文档视为苦差事。因此，他们尽可能地推迟了。</p><blockquote><p>Unfortunately, this approach has several negative consequences. First, delaying documentation often means that it never gets written at all. Once you start delaying, it’s easy to delay a bit more; after all, the code will be even more stable in a few more weeks. By the time the code has inarguably stabilized, there is a lot of it, which means the task of writing documentation has become huge and even less attractive. There’s never a convenient time to stop for a few days and fill in all of the missing comments, and it’s easy to rationalize that the best thing for the project is to move on and fix bugs or write the next new feature. This will create even more undocumented code.</p></blockquote><p>不幸的是，这种方法有几个负面影响。首先，延迟文档通常意味着根本无法编写文档。一旦开始延迟，就容易再延迟一些。毕竟，代码将在几周后变得更加稳定。到了代码毫无疑问地稳定下来的时候，代码已经很多了，这意味着编写文档的任务变得越来越庞大，甚至没有了吸引力。从来没有一个合适的时间可以停下来几天并填写所有缺失的注释，并且很容易合理化项目最好的事情是继续前进并修复错误或编写下一个新功能。这将导致更多没有注释的代码。</p><blockquote><p>Even if you do have the self-discipline to go back and write the comments (and don’t fool yourself: you probably don’t), the comments won’t be very good. By this time in the process, you have checked out mentally. In your mind, this piece of code is done; you are eager to move on to your next project. You know that writing comments is the right thing to do, but it’s no fun. You just want to get through it as quickly as possible. Thus, you make a quick pass over the code, adding just enough comments to look respectable. By now, it’s been a while since you designed the code, so your memories of the design process are becoming fuzzy. You look at the code as you are writing the comments, so the comments repeat the code. Even if you try to reconstruct the design ideas that aren’t obvious from the code, there will be things you don’t remember. Thus, the comments are missing some of the most important things they should describe.</p></blockquote><p>即使您有自律性回去写注释(不要欺骗您自己:您可能没有)，注释也不会很好。在这个过程的这个时候，你已经在精神上离开了。在你的脑海中，这段代码已经完成了;你急于开始下一个项目。你知道写注释是正确的事情，但它没有乐趣。你只想尽快度过难关。因此，您快速地浏览代码，添加足够的注释以使其看起来令人满意。到目前为止，您设计代码已经有一段时间了，所以您对设计过程的记忆变得模糊了。您查看代码完成注释，因此注释重复了代码(comments repeat the code)。即使您试图重构代码中不明显的设计思想，也会有您不记得的事情。因此，这些注释遗漏了一些他们应该描述的最重要的事情。</p><h2 id="_15-2-write-the-comments-first-首先写注释" tabindex="-1">15.2 Write the comments first 首先写注释 <a class="header-anchor" href="#_15-2-write-the-comments-first-首先写注释" aria-label="Permalink to &quot;15.2 Write the comments first 首先写注释&quot;">​</a></h2><blockquote><p>I use a different approach to writing comments, where I write the comments at the very beginning:</p></blockquote><p>我使用一种不同的方法来编写注释，在开始时就写注释：</p><blockquote><ul><li>For a new class, I start by writing the class interface comment.</li><li>Next, I write interface comments and signatures for the most important public methods, but I leave the method bodies empty.</li><li>I iterate a bit over these comments until the basic structure feels about right.</li><li>At this point I write declarations and comments for the most important class instance variables in the class.</li><li>Finally, I fill in the bodies of the methods, adding implementation comments as needed.</li><li>While writing method bodies, I usually discover the need for additional methods and instance variables. For each new method I write the interface comment before the body of the method; for instance variables I fill in the comment at the same time that I write the variable declaration.</li></ul></blockquote><hr><ul><li>对于新类，我首先编写类接口注释。</li><li>接下来，我为最重要的公共方法编写接口注释和签名，但将方法主体保留为空。</li><li>我对这些注释进行了迭代，直到基本结构感觉正确为止。</li><li>此时我为类中最重要的类实例变量编写了声明和注释。</li><li>最后，我填写方法的主体，并根据需要添加实现注释。</li><li>在编写方法主体时，我通常会发现需要其他方法和实例变量。对于每个新方法，我在方法主体之前编写接口注释。对于每个变量，我在编写其声明的同时填写了注释。</li></ul><blockquote><p>When the code is done, the comments are also done. There is never a backlog of unwritten comments.</p></blockquote><p>代码完成后，注释也将完成。从来没有积压的书面注释。</p><blockquote><p>The comments-first approach has three benefits. First, it produces better comments. If you write the comments as you are designing the class, the key design issues will be fresh in your mind, so it’s easy to record them. It’s better to write the interface comment for each method before its body, so you can focus on the method’s abstraction and interface without being distracted by its implementation. During the coding and testing process you will notice and fix problems with the comments. As a result, the comments improve over the course of development.</p></blockquote><p>注释优先的方法具有三个好处。首先，它会产生更好的注释。如果您在设计类时写注释，那么关键的设计问题将在您的脑海中浮现，因此很容易记录下来。最好在每个方法的主体之前编写接口注释，这样您就可以专注于方法的抽象和接口，而不会因其实现而分心。在编码和测试过程中，您会注意到并修复注释中的问题。结果，注释在开发过程中得到了改善。</p><h2 id="_15-3-comments-are-a-design-tool-注释是一种设计工具" tabindex="-1">15.3 Comments are a design tool 注释是一种设计工具 <a class="header-anchor" href="#_15-3-comments-are-a-design-tool-注释是一种设计工具" aria-label="Permalink to &quot;15.3 Comments are a design tool 注释是一种设计工具&quot;">​</a></h2><blockquote><p>The second, and most important, benefit of writing the comments at the beginning is that it improves the system design. Comments provide the only way to fully capture abstractions, and good abstractions are fundamental to good system design. If you write comments describing the abstractions at the beginning, you can review and tune them before writing implementation code. To write a good comment, you must identify the essence of a variable or piece of code: what are the most important aspects of this thing? It’s important to do this early in the design process; otherwise you are just hacking code.</p></blockquote><p>在开始时编写注释的第二个也是最重要的好处是可以改善系统设计。注释提供了完全捕获抽象的唯一方法，好的抽象是好的系统设计的基础。如果您在一开始就写了描述抽象的注释，则可以在编写实现代码之前对其进行检查和调整。要写一个好的注释，您必须确定一个变量或一段代码的本质：这件事最重要的方面是什么？在设计过程的早期进行此操作很重要；否则，您只是在破解代码(hacking code 未找到合适的翻译)。</p><blockquote><p>Comments serve as a canary in the coal mine of complexity. If a method or variable requires a long comment, it is a red flag that you don’t have a good abstraction. Remember from Chapter 4 that classes should be deep: the best classes have very simple interfaces yet implement powerful functions. The best way to judge the complexity of an interface is from the comments that describe it. If the interface comment for a method provides all the information needed to use the method and is also short and simple, that indicates that the method has a simple interface. Conversely, if there’s no way to describe a method completely without a long and complicated comment, then the method has a complex interface. You can compare a method’s interface comment with the implementation to get a sense of how deep the method is: if the interface comment must describe all the major features of the implementation, then the method is shallow. The same idea applies to variables: if it takes a long comment to fully describe a variable, it’s a red flag that suggests you may not have chosen the right variable decomposition. Overall, the act of writing comments allows you to evaluate your design decisions early, so you can discover and fix problems.</p></blockquote><p>注释是复杂煤矿中的金丝雀。如果方法或变量需要较长的注释，则它是一个危险信号，表明您没有很好的抽象。请记住，在第 4 章中，类应该很深：最好的类具有非常简单的接口，但可以实现强大的功能。判断接口复杂性的最佳方法是从描述接口的注释中进行。如果某个方法的接口注释提供了使用该方法所需的所有信息，并且又简短又简单，则表明该方法具有简单的接口。相反，如果没有冗长而复杂的注释无法完全描述一个方法，则该方法具有复杂的接口。您可以将方法的接口注释与实现进行比较，以了解该方法的深度：如果接口注释必须描述实现的所有主要功能，则该方法很浅。同样的想法也适用于变量：如果要花很长的时间来完整描述一个变量，那是一个危险信号，表明您可能没有选择正确的变量分解。总体而言，编写注释的行为使您可以及早评估设计决策，以便发现并解决问题。</p><blockquote><p>img Red Flag: Hard to Describe img</p></blockquote><blockquote><p>The comment that describes a method or variable should be simple and yet complete. If you find it difficult to write such a comment, that’s an indicator that there may be a problem with the design of the thing you are describing.</p></blockquote><p>描述方法或变量的注释应该简单而完整。如果您发现很难写这样的注释，则表明您所描述的内容的设计可能存在问题。</p><blockquote><p>Of course, comments are only a good indicator of complexity if they are complete and clear. If you write a method interface comment that doesn’t provide all the information needed to invoke the method, or one that is so cryptic that it’s hard to understand, then that comment doesn’t provide a good measure of the method’s depth.</p></blockquote><p>当然，如果注释完整而清晰，那么它们仅是复杂性的良好指标。如果编写的方法接口注释未提供调用该方法所需的全部信息，或者编写的注释太过晦涩难懂，那么则该注释不能很好地衡量该方法的深度。</p><h2 id="_15-4-early-comments-are-fun-comments-早期注释很有趣" tabindex="-1">15.4 Early comments are fun comments 早期注释很有趣 <a class="header-anchor" href="#_15-4-early-comments-are-fun-comments-早期注释很有趣" aria-label="Permalink to &quot;15.4 Early comments are fun comments 早期注释很有趣&quot;">​</a></h2><blockquote><p>The third and final benefit of writing comments early is that it makes comment-writing more fun. For me, one of the most enjoyable parts of programming is the early design phase for a new class, where I’m fleshing out the abstractions and structure for the class. Most of my comments are written during this phase, and the comments are how I record and test the quality of my design decisions. I’m looking for the design that can be expressed completely and clearly in the fewest words. The simpler the comments, the better I feel about my design, so finding simple comments is a source of pride. If you are programming strategically, where your main goal is a great design rather than just writing code that works, then writing comments should be fun, since that’s how you identify the best designs.</p></blockquote><p>尽早编写注释的第三个也是最后一个好处是，它使编写注释更加有趣。对我来说，编程中最有趣的部分之一是新类的早期设计阶段，我在这个阶段充实类的抽象和结构。我的大部分注释都是在此阶段编写的，这些注释是我记录和测试设计决策质量的方式。我正在寻找可以用最少的词来完整而清晰地表达的设计。注释越简单，我对设计的感觉就越好，因此找到简单的注释是一种自豪感。如果您是策略性编程，而您的主要目标是一个出色的设计，而不仅仅是编写有效的代码，那么编写注释应该很有趣，因为这是您确定最佳设计的方式。</p><h2 id="_15-5-are-early-comments-expensive-早期注释是否昂贵" tabindex="-1">15.5 Are early comments expensive? 早期注释是否昂贵？ <a class="header-anchor" href="#_15-5-are-early-comments-expensive-早期注释是否昂贵" aria-label="Permalink to &quot;15.5 Are early comments expensive? 早期注释是否昂贵？&quot;">​</a></h2><blockquote><p>Now let’s revisit the argument for delaying comments, which is that it avoids the cost of reworking the comments as the code evolves. A simple back-of-the-envelope calculation will show that this doesn’t save much. First, estimate the total fraction of development time that you spend typing in code and comments together, including time to revise code and comments; it’s unlikely that this will be more than about 10% of all development time. Even if half of your total code lines are comments, writing comments probably doesn’t account for more than about 5% of your total development time. Delaying the comments until the end will save only a fraction of this, which isn’t very much.</p></blockquote><p>现在，让我们重新审视延迟注释的论点，它避免了在代码演变时重新处理注释的成本。一个简单的粗略计算会表明这并没有节省多少。首先，估算您一起键入代码和注释所花费的开发时间的总和，包括修改代码和注释的时间；这不太可能超过所有开发时间的 10％。即使您的全部代码行中有一半是注释，编写注释也可能不会占开发总时间的 5％以上。将注释延迟到最后只会节省其中的一小部分，这不是很多。</p><blockquote><p>Writing the comments first will mean that the abstractions will be more stable before you start writing code. This will probably save time during coding. In contrast, if you write the code first, the abstractions will probably evolve as you code, which will require more code revisions than the comments-first approach. When you consider all of these factors, it’s possible that it might be faster overall to write the comments first.</p></blockquote><p>首先编写注释将意味着在开始编写代码之前，抽象将更加稳定。这可能会节省编码时间。相反，如果您首先编写代码，则抽象可能会随代码的发展而变化，与注释优先方法相比，将需要更多的代码修订。当您考虑所有这些因素时，首先编写注释可能总体上更快。</p><h2 id="_15-6-conclusion-结论" tabindex="-1">15.6 Conclusion 结论 <a class="header-anchor" href="#_15-6-conclusion-结论" aria-label="Permalink to &quot;15.6 Conclusion 结论&quot;">​</a></h2><blockquote><p>If you haven’t ever tried writing the comments first, give it a try. Stick with it long enough to get used to it. Then think about how it affects the quality of your comments, the quality of your design, and your overall enjoyment of software development. After you have tried this for a while, let me know whether your experience matches mine, and why or why not.</p></blockquote><p>如果您从未尝试过先编写注释，请尝试一下。坚持足够长的时间来习惯它。然后考虑它如何影响您的注释质量，设计质量以及软件开发的整体乐趣。在尝试了一段时间之后，让我知道您的经历是否与我的相符，以及为什么或为什么不这样。</p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><div class="edit-link" data-v-e257564d><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh/edit/main/docs/ch15.md" target="_blank" rel="noreferrer" data-v-e257564d><!--[--><span class="vpi-square-pen edit-link-icon" data-v-e257564d></span> Edit this page<!--]--></a></div><div class="last-updated" data-v-e257564d><p class="VPLastUpdated" data-v-e257564d data-v-e98dd255>Last updated: <time datetime="2025-06-01T06:59:43.000Z" data-v-e98dd255></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/A-Philosophy-of-Software-Design-zh/ch14.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>第 14 章 选择的名字</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/A-Philosophy-of-Software-Design-zh/ch16.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>第 16 章 修改现有的代码</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"ch01.md\":\"CT4RebPr\",\"ch02.md\":\"DzC-uUcq\",\"ch03.md\":\"BdbHgJH4\",\"ch04.md\":\"NfvuhAOS\",\"ch05.md\":\"NrM4_jLw\",\"ch06.md\":\"x-WZhrXd\",\"ch07.md\":\"BtsjWDyl\",\"ch08.md\":\"DrbKdy-y\",\"ch09.md\":\"DJ1EdMsZ\",\"ch10.md\":\"CxyLE3HW\",\"ch11.md\":\"DXLFmb9y\",\"ch12.md\":\"DXQBlcdI\",\"ch13.md\":\"CuzvIH41\",\"ch14.md\":\"CaxU4zwU\",\"ch15.md\":\"cIjUFAql\",\"ch16.md\":\"CwU4dqAs\",\"ch17.md\":\"BJI2hjnk\",\"ch18.md\":\"e9bRLM4x\",\"ch19.md\":\"hdUqlVke\",\"ch20.md\":\"x8Vu7n7n\",\"ch21.md\":\"PgNlvRER\",\"index.md\":\"PocvVwcn\",\"preface.md\":\"5UGGXcMW\",\"summary.md\":\"C6nSSoRW\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"《软件设计的哲学》中文版\",\"description\":\"软件设计的哲学 约翰·奥斯特豪特; A Philosophy of Software Design 中文翻译; 軟件設計的哲學 (第2版) 約翰·奧斯特豪特\",\"base\":\"/A-Philosophy-of-Software-Design-zh/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"主页\",\"link\":\"/\"},{\"text\":\"章节正文\",\"link\":\"/ch01\"},{\"text\":\"全书总结\",\"link\":\"/summary\"}],\"sidebar\":[{\"text\":\"目录\",\"items\":[{\"text\":\"前言\",\"link\":\"/preface\"},{\"text\":\"第 1 章 介绍\",\"link\":\"/ch01\"},{\"text\":\"第 2 章 复杂性的本质\",\"link\":\"/ch02\"},{\"text\":\"第 3 章 工作代码是不够的\",\"link\":\"/ch03\"},{\"text\":\"第 4 章 模块应该是深的\",\"link\":\"/ch04\"},{\"text\":\"第 5 章 信息隐藏(和泄漏)\",\"link\":\"/ch05\"},{\"text\":\"第 6 章 通用模块更深入\",\"link\":\"/ch06\"},{\"text\":\"第 7 章 不同的层，不同的抽象\",\"link\":\"/ch07\"},{\"text\":\"第 8 章 降低复杂性\",\"link\":\"/ch08\"},{\"text\":\"第 9 章 在一起更好还是分开更好？\",\"link\":\"/ch09\"},{\"text\":\"第 10 章 定义不存在的错误\",\"link\":\"/ch10\"},{\"text\":\"第 11 章 设计它两次\",\"link\":\"/ch11\"},{\"text\":\"第 12 章 为什么要写注释呢？有四个理由\",\"link\":\"/ch12\"},{\"text\":\"第 13 章 注释应该描述代码中不明显的内容\",\"link\":\"/ch13\"},{\"text\":\"第 14 章 选择的名字\",\"link\":\"/ch14\"},{\"text\":\"第 15 章 先写注释\",\"link\":\"/ch15\"},{\"text\":\"第 16 章 修改现有的代码\",\"link\":\"/ch16\"},{\"text\":\"第 17 章 一致性\",\"link\":\"/ch17\"},{\"text\":\"第 18 章 代码应该是显而易见的\",\"link\":\"/ch18\"},{\"text\":\"第 19 章 软件发展趋势\",\"link\":\"/ch19\"},{\"text\":\"第 20 章 设计性能\",\"link\":\"/ch20\"},{\"text\":\"第 21 章 结论\",\"link\":\"/ch21\"},{\"text\":\"总结\",\"link\":\"/summary\"}]}],\"search\":{\"provider\":\"local\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh\"}],\"editLink\":{\"pattern\":\"https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh/edit/main/docs/:path\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>