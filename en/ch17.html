<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Chapter 17 Consistency | <A Philosophy of Software Design></title><meta name="description" content="">
    <link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/app.466a0dd3.js"><link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/ch17.html.4d5bdd5a.js"><link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/ch17.html.b6efeae9.js">
    <link rel="stylesheet" href="/A-Philosophy-of-Software-Design-zh/assets/style.79799630.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/A-Philosophy-of-Software-Design-zh/en/" class=""><!----><span class="site-name">&lt;A Philosophy of Software Design&gt;</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/A-Philosophy-of-Software-Design-zh/ch17.html" class="" aria-label="简体中文"><!--[--><!--]--> 简体中文 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch17.html" class="router-link-active router-link-exact-active router-link-active" aria-label="English"><!--[--><!--]--> English <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/A-Philosophy-of-Software-Design-zh/ch17.html" class="" aria-label="简体中文"><!--[--><!--]--> 简体中文 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch17.html" class="router-link-active router-link-exact-active router-link-active" aria-label="English"><!--[--><!--]--> English <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/A-Philosophy-of-Software-Design-zh/en/preface.html" class="sidebar-item sidebar-heading" aria-label="Preface"><!--[--><!--]--> Preface <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch01.html" class="sidebar-item sidebar-heading" aria-label="Chapter 1 Introduction(It’s All About Complexity)"><!--[--><!--]--> Chapter 1 Introduction(It’s All About Complexity) <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch02.html" class="sidebar-item sidebar-heading" aria-label="Chapter 2 The Nature of Complexity"><!--[--><!--]--> Chapter 2 The Nature of Complexity <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch03.html" class="sidebar-item sidebar-heading" aria-label="Chapter 3 Working Code Isn’t Enough(Strategic vs. Tactical Programming)"><!--[--><!--]--> Chapter 3 Working Code Isn’t Enough(Strategic vs. Tactical Programming) <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch04.html" class="sidebar-item sidebar-heading" aria-label="Chapter 4 Modules Should Be Deep"><!--[--><!--]--> Chapter 4 Modules Should Be Deep <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch05.html" class="sidebar-item sidebar-heading" aria-label="Chapter 5 Information Hiding (and Leakage)"><!--[--><!--]--> Chapter 5 Information Hiding (and Leakage) <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch06.html" class="sidebar-item sidebar-heading" aria-label="Chapter 6 General-Purpose Modules are Deeper"><!--[--><!--]--> Chapter 6 General-Purpose Modules are Deeper <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch07.html" class="sidebar-item sidebar-heading" aria-label="Chapter 7 Different Layer, Different Abstraction"><!--[--><!--]--> Chapter 7 Different Layer, Different Abstraction <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch08.html" class="sidebar-item sidebar-heading" aria-label="Chapter 8 Pull Complexity Downwards"><!--[--><!--]--> Chapter 8 Pull Complexity Downwards <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch09.html" class="sidebar-item sidebar-heading" aria-label="Chapter 9 Better Together Or Better Apart?"><!--[--><!--]--> Chapter 9 Better Together Or Better Apart? <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch10.html" class="sidebar-item sidebar-heading" aria-label="Chapter 10 Define Errors Out Of Existence"><!--[--><!--]--> Chapter 10 Define Errors Out Of Existence <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch11.html" class="sidebar-item sidebar-heading" aria-label="Chapter 11 Design it Twice"><!--[--><!--]--> Chapter 11 Design it Twice <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch12.html" class="sidebar-item sidebar-heading" aria-label="Chapter 12 Why Write Comments? The Four Excuses"><!--[--><!--]--> Chapter 12 Why Write Comments? The Four Excuses <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch13.html" class="sidebar-item sidebar-heading" aria-label="Chapter 13 Comments Should Describe Things that Aren’t Obvious from the Code"><!--[--><!--]--> Chapter 13 Comments Should Describe Things that Aren’t Obvious from the Code <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch14.html" class="sidebar-item sidebar-heading" aria-label="Chapter 14 Choosing Names"><!--[--><!--]--> Chapter 14 Choosing Names <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch15.html" class="sidebar-item sidebar-heading" aria-label="Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process)"><!--[--><!--]--> Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process) <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch16.html" class="sidebar-item sidebar-heading" aria-label="Chapter 16 Modifying Existing Code"><!--[--><!--]--> Chapter 16 Modifying Existing Code <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch17.html" class="router-link-active router-link-exact-active router-link-active sidebar-item sidebar-heading active" aria-label="Chapter 17 Consistency"><!--[--><!--]--> Chapter 17 Consistency <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch17.html#_17-1-examples-of-consistency" class="router-link-active router-link-exact-active sidebar-item" aria-label="17.1 Examples of consistency"><!--[--><!--]--> 17.1 Examples of consistency <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch17.html#_17-2-ensuring-consistency" class="router-link-active router-link-exact-active sidebar-item" aria-label="17.2 Ensuring consistency"><!--[--><!--]--> 17.2 Ensuring consistency <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch17.html#_17-3-taking-it-too-far" class="router-link-active router-link-exact-active sidebar-item" aria-label="17.3 Taking it too far"><!--[--><!--]--> 17.3 Taking it too far <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch17.html#_17-4-conclusion" class="router-link-active router-link-exact-active sidebar-item" aria-label="17.4 Conclusion"><!--[--><!--]--> 17.4 Conclusion <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch18.html" class="sidebar-item sidebar-heading" aria-label="Chapter 18 Code Should be Obvious"><!--[--><!--]--> Chapter 18 Code Should be Obvious <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch19.html" class="sidebar-item sidebar-heading" aria-label="Chapter 19 Software Trends"><!--[--><!--]--> Chapter 19 Software Trends <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch20.html" class="sidebar-item sidebar-heading" aria-label="Chapter 20 Designing for Performance"><!--[--><!--]--> Chapter 20 Designing for Performance <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch21.html" class="sidebar-item sidebar-heading" aria-label="Chapter 21 Conclusion"><!--[--><!--]--> Chapter 21 Conclusion <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/summary.html" class="sidebar-item sidebar-heading" aria-label="Summary"><!--[--><!--]--> Summary <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="chapter-17-consistency" tabindex="-1"><a class="header-anchor" href="#chapter-17-consistency" aria-hidden="true">#</a> Chapter 17 Consistency</h1><p>Consistency is a powerful tool for reducing the complexity of a system and making its behavior more obvious. If a system is consistent, it means that similar things are done in similar ways, and dissimilar things are done in different ways. Consistency creates cognitive leverage: once you have learned how something is done in one place, you can use that knowledge to immediately understand other places that use the same approach. If a system is not implemented in a consistent fashion, developers must learn about each situation separately. This will take more time.</p><p>Consistency reduces mistakes. If a system is not consistent, two situations may appear the same when in fact they are different. A developer may see a pattern that looks familiar and make incorrect assumptions based on previous encounters with that pattern. On the other hand, if the system is consistent, assumptions made based on familiar-looking situations will be safe. Consistency allows developers to work more quickly with fewer mistakes.</p><h2 id="_17-1-examples-of-consistency" tabindex="-1"><a class="header-anchor" href="#_17-1-examples-of-consistency" aria-hidden="true">#</a> 17.1 Examples of consistency</h2><p>Consistency can be applied at many levels in a system; here are a few examples.</p><p>Names. Chapter 14 has already discussed the benefits of using names in a consistent way.</p><p>Coding style. It is common nowadays for development organizations to have style guides that restrict program structure beyond the rules enforced by compilers. Modern style guides address a range of issues, such as indentation, curly-brace placement, order of declarations, naming, commenting, and restrictions on language features considered dangerous. Style guidelines make code easier to read and can reduce some kinds of errors.</p><p>Interfaces. An interface with multiple implementations is another example of consistency. Once you understand one implementation of the interface, any other implementation becomes easier to understand because you already know the features it will have to provide.</p><p>Design patterns. Design patterns are generally-accepted solutions to certain common problems, such as the model-view-controller approach to user interface design. If you can use an existing design pattern to solve the problem, the implementation will proceed more quickly, it is more likely to work, and your code will be more obvious to readers. Design patterns are discussed in more detail in Section 19.5.</p><p>Invariants. An invariant is a property of a variable or structure that is always true. For example, a data structure storing lines of text might enforce an invariant that each line is terminated by a newline character. Invariants reduce the number of special cases that must be considered in code and make it easier to reason about the code’s behavior.</p><h2 id="_17-2-ensuring-consistency" tabindex="-1"><a class="header-anchor" href="#_17-2-ensuring-consistency" aria-hidden="true">#</a> 17.2 Ensuring consistency</h2><p>Consistency is hard to maintain, especially when many people work on a project over a long time. People in one group may not know about conventions established in another group. Newcomers don’t know the rules, so they unintentionally violate the conventions and create new conventions that conflict with existing ones. Here are a few tips for establishing and maintaining consistency:</p><p>Document. Create a document that lists the most important overall conventions, such as coding style guidelines. Place the document in a spot where developers are likely to see it, such as a conspicuous place on the project Wiki. Encourage new people joining the group to read the document, and encourage existing people to review it every once in a while. Several style guides from various organizations have been published on the Web; consider starting with one of these.</p><p>For conventions that are more localized, such as invariants, find an appropriate spot in the code to document them. If you don’t write the conventions down, it’s unlikely that other people will follow them.</p><p>Enforce. Even with good documentation, it’s hard for developers to remember all of the conventions. The best way to enforce conventions is to write a tool that checks for violations, and make sure that code cannot be committed to the repository unless it passes the checker. Automated checkers work particularly well for low-level syntactic conventions.</p><p>One of my recent projects had problems with line termination characters. Some developers worked on Unix, where lines are terminated by newlines; others worked on Windows, where lines are normally terminated by a carriage-return followed by a newline. If a developer on one system made a small edit to a file previously edited on the other system, the editor would sometimes replace all of the line terminators with ones appropriate for that system. This gave the appearance that every line of the file had been modified, which made it hard to track the meaningful changes. We established a convention that files should contain newlines only, but it was hard to ensure that every tool used by every developer followed the convention. Every time a new developer joined the project, we would experience a rash of line termination problems while that developer adjusted to the convention.</p><p>We eventually solved this problem by writing a short script that was executed automatically before changes are committed to the source code repository. The script checks all of the files that have been modified and aborts the commit if any of them contain carriage returns. The script can also be run manually to repair damaged files by replacing carriage-return/newline sequences with newlines. This instantly eliminated the problems, and it also helped train new developers.</p><p>Code reviews provide another opportunity for enforcing conventions and for educating new developers about the conventions. The more nit-picky that code reviewers are, the more quickly everyone on the team will learn the conventions, and the cleaner the code will be.</p><p>When in Rome ... The most important convention of all is that every developer should follow the old adage “When in Rome, do as the Romans do.” When working in a new file, look around to see how the existing code is structured. Are all public variables and methods declared before private ones? Are the methods in alphabetical order? Do variables use “camel case,” as in firstServerName, or “snake case,” as in first_server_name? When you see anything that looks like it might possibly be a convention, follow it. When making a design decision, ask yourself if it’s likely that a similar decision was made elsewhere in the project; if so, find an existing example and use the same approach in your new code.</p><p>Don’t change existing conventions. Resist the urge to “improve” on existing conventions. Having a “better idea” is not a sufficient excuse to introduce inconsistencies. Your new idea may indeed be better, but the value of consistency over inconsistency is almost always greater than the value of one approach over another. Before introducing inconsistent behavior, ask yourself two questions. First, do you have significant new information justifying your approach that wasn’t available when the old convention was established? Second, is the new approach so much better that it is worth taking the time to update all of the old uses? If your organization agrees that the answers to both questions are “yes,” then go ahead and make the upgrade; when you are done, there should be no sign of the old convention. However, you still run the risk that other developers will not know about the new convention, so they may reintroduce the old approach in the future. Overall, reconsidering established conventions is rarely a good use of developer time.</p><h2 id="_17-3-taking-it-too-far" tabindex="-1"><a class="header-anchor" href="#_17-3-taking-it-too-far" aria-hidden="true">#</a> 17.3 Taking it too far</h2><p>Consistency means not only that similar things should be done in similar ways, but that dissimilar things should be done in different ways. If you become overzealous about consistency and try to force dissimilar things into the same approach, such as by using the same variable name for things that are really different or using an existing design pattern for a task that doesn’t fit the pattern, you’ll create complexity and confusion. Consistency only provides benefits when developers have confidence that “if it looks like an x, it really is an x.”</p><h2 id="_17-4-conclusion" tabindex="-1"><a class="header-anchor" href="#_17-4-conclusion" aria-hidden="true">#</a> 17.4 Conclusion</h2><p>Consistency is another example of the investment mindset. It will take a bit of extra work to ensure consistency: work to decide on conventions, work to create automated checkers, work to look for similar situations to mimic in new code, and work in code reviews to educate the team. The return on this investment is that your code will be more obvious. Developers will be able to understand the code’s behavior more quickly and accurately, and this will allow them to work faster, with fewer bugs.</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/A-Philosophy-of-Software-Design-zh/en/ch16.html" class="" aria-label="Chapter 16 Modifying Existing Code"><!--[--><!--]--> Chapter 16 Modifying Existing Code <!--[--><!--]--></a></span><span class="next"><a href="/A-Philosophy-of-Software-Design-zh/en/ch18.html" class="" aria-label="Chapter 18 Code Should be Obvious"><!--[--><!--]--> Chapter 18 Code Should be Obvious <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/A-Philosophy-of-Software-Design-zh/assets/app.466a0dd3.js" defer></script>
  </body>
</html>
