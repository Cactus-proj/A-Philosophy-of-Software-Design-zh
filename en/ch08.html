<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Chapter 8 Pull Complexity Downwards | <A Philosophy of Software Design></title><meta name="description" content="">
    <link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/app.466a0dd3.js"><link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/ch08.html.8a4c2452.js"><link rel="modulepreload" href="/A-Philosophy-of-Software-Design-zh/assets/ch08.html.ef3cb45c.js">
    <link rel="stylesheet" href="/A-Philosophy-of-Software-Design-zh/assets/style.79799630.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/A-Philosophy-of-Software-Design-zh/en/" class=""><!----><span class="site-name">&lt;A Philosophy of Software Design&gt;</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/A-Philosophy-of-Software-Design-zh/ch08.html" class="" aria-label="简体中文"><!--[--><!--]--> 简体中文 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch08.html" class="router-link-active router-link-exact-active router-link-active" aria-label="English"><!--[--><!--]--> English <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/A-Philosophy-of-Software-Design-zh/ch08.html" class="" aria-label="简体中文"><!--[--><!--]--> 简体中文 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch08.html" class="router-link-active router-link-exact-active router-link-active" aria-label="English"><!--[--><!--]--> English <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/A-Philosophy-of-Software-Design-zh/en/preface.html" class="sidebar-item sidebar-heading" aria-label="Preface"><!--[--><!--]--> Preface <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch01.html" class="sidebar-item sidebar-heading" aria-label="Chapter 1 Introduction(It’s All About Complexity)"><!--[--><!--]--> Chapter 1 Introduction(It’s All About Complexity) <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch02.html" class="sidebar-item sidebar-heading" aria-label="Chapter 2 The Nature of Complexity"><!--[--><!--]--> Chapter 2 The Nature of Complexity <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch03.html" class="sidebar-item sidebar-heading" aria-label="Chapter 3 Working Code Isn’t Enough(Strategic vs. Tactical Programming)"><!--[--><!--]--> Chapter 3 Working Code Isn’t Enough(Strategic vs. Tactical Programming) <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch04.html" class="sidebar-item sidebar-heading" aria-label="Chapter 4 Modules Should Be Deep"><!--[--><!--]--> Chapter 4 Modules Should Be Deep <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch05.html" class="sidebar-item sidebar-heading" aria-label="Chapter 5 Information Hiding (and Leakage)"><!--[--><!--]--> Chapter 5 Information Hiding (and Leakage) <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch06.html" class="sidebar-item sidebar-heading" aria-label="Chapter 6 General-Purpose Modules are Deeper"><!--[--><!--]--> Chapter 6 General-Purpose Modules are Deeper <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch07.html" class="sidebar-item sidebar-heading" aria-label="Chapter 7 Different Layer, Different Abstraction"><!--[--><!--]--> Chapter 7 Different Layer, Different Abstraction <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch08.html" class="router-link-active router-link-exact-active router-link-active sidebar-item sidebar-heading active" aria-label="Chapter 8 Pull Complexity Downwards"><!--[--><!--]--> Chapter 8 Pull Complexity Downwards <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch08.html#_8-1-example-editor-text-class" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.1 Example: editor text class"><!--[--><!--]--> 8.1 Example: editor text class <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch08.html#_8-2-example-configuration-parameters" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.2 Example: configuration parameters"><!--[--><!--]--> 8.2 Example: configuration parameters <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch08.html#_8-3-taking-it-too-far" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.3 Taking it too far"><!--[--><!--]--> 8.3 Taking it too far <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/A-Philosophy-of-Software-Design-zh/en/ch08.html#_8-4-conclusion" class="router-link-active router-link-exact-active sidebar-item" aria-label="8.4 Conclusion"><!--[--><!--]--> 8.4 Conclusion <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch09.html" class="sidebar-item sidebar-heading" aria-label="Chapter 9 Better Together Or Better Apart?"><!--[--><!--]--> Chapter 9 Better Together Or Better Apart? <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch10.html" class="sidebar-item sidebar-heading" aria-label="Chapter 10 Define Errors Out Of Existence"><!--[--><!--]--> Chapter 10 Define Errors Out Of Existence <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch11.html" class="sidebar-item sidebar-heading" aria-label="Chapter 11 Design it Twice"><!--[--><!--]--> Chapter 11 Design it Twice <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch12.html" class="sidebar-item sidebar-heading" aria-label="Chapter 12 Why Write Comments? The Four Excuses"><!--[--><!--]--> Chapter 12 Why Write Comments? The Four Excuses <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch13.html" class="sidebar-item sidebar-heading" aria-label="Chapter 13 Comments Should Describe Things that Aren’t Obvious from the Code"><!--[--><!--]--> Chapter 13 Comments Should Describe Things that Aren’t Obvious from the Code <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch14.html" class="sidebar-item sidebar-heading" aria-label="Chapter 14 Choosing Names"><!--[--><!--]--> Chapter 14 Choosing Names <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch15.html" class="sidebar-item sidebar-heading" aria-label="Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process)"><!--[--><!--]--> Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process) <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch16.html" class="sidebar-item sidebar-heading" aria-label="Chapter 16 Modifying Existing Code"><!--[--><!--]--> Chapter 16 Modifying Existing Code <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch17.html" class="sidebar-item sidebar-heading" aria-label="Chapter 17 Consistency"><!--[--><!--]--> Chapter 17 Consistency <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch18.html" class="sidebar-item sidebar-heading" aria-label="Chapter 18 Code Should be Obvious"><!--[--><!--]--> Chapter 18 Code Should be Obvious <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch19.html" class="sidebar-item sidebar-heading" aria-label="Chapter 19 Software Trends"><!--[--><!--]--> Chapter 19 Software Trends <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch20.html" class="sidebar-item sidebar-heading" aria-label="Chapter 20 Designing for Performance"><!--[--><!--]--> Chapter 20 Designing for Performance <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/ch21.html" class="sidebar-item sidebar-heading" aria-label="Chapter 21 Conclusion"><!--[--><!--]--> Chapter 21 Conclusion <!--[--><!--]--></a><!----></li><li><a href="/A-Philosophy-of-Software-Design-zh/en/summary.html" class="sidebar-item sidebar-heading" aria-label="Summary"><!--[--><!--]--> Summary <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="chapter-8-pull-complexity-downwards" tabindex="-1"><a class="header-anchor" href="#chapter-8-pull-complexity-downwards" aria-hidden="true">#</a> Chapter 8 Pull Complexity Downwards</h1><p>This chapter introduces another way of thinking about how to create deeper classes. Suppose that you are developing a new module, and you discover a piece of unavoidable complexity. Which is better: should you let users of the module deal with the complexity, or should you handle the complexity internally within the module? If the complexity is related to the functionality provided by the module, then the second answer is usually the right one. Most modules have more users than developers, so it is better for the developers to suffer than the users. As a module developer, you should strive to make life as easy as possible for the users of your module, even if that means extra work for you. Another way of expressing this idea is that it is more important for a module to have a simple interface than a simple implementation.</p><p>As a developer, it’s tempting to behave in the opposite fashion: solve the easy problems and punt the hard ones to someone else. If a condition arises that you’re not certain how to deal with, the easiest thing is to throw an exception and let the caller handle it. If you are not certain what policy to implement, you can define a few configuration parameters to control the policy and leave it up to the system administrator to figure out the best values for them.</p><p>Approaches like these will make your life easier in the short term, but they amplify complexity, so that many people must deal with a problem, rather than just one person. For example, if a class throws an exception, every caller of the class will have to deal with it. If a class exports configuration parameters, every system administrator in every installation will have to learn how to set them.</p><h2 id="_8-1-example-editor-text-class" tabindex="-1"><a class="header-anchor" href="#_8-1-example-editor-text-class" aria-hidden="true">#</a> 8.1 Example: editor text class</h2><p>Consider the class that manages the text of a file for a GUI text editor, which was discussed in Chapters 6 and 7. The class provides methods to read a file from disk into memory, query and modify the in-memory copy of the file, and write the modified version back to disk. When students had to implement this class, many of them chose a line-oriented interface, with methods to read, insert, and delete whole lines of text. This resulted in a simple implementation for the class, but it created complexity for higher level software. At the level of the user interface, operations rarely involve whole lines. For example, keystrokes cause individual characters to be inserted within an existing line; copying or deleting the selection can modify parts of several different lines. With the line-oriented text interface, higher-level software had to split and join lines in order to implement the user interface.</p><p>A character-oriented interface such as the one described in Section 6.3 pulls complexity downward. The user interface software can now insert and delete arbitrary ranges of text without splitting and merging lines, so it becomes simpler. The implementation of the text class probably becomes more complex: if it represents the text internally as a collection of lines, it will have to split and merge lines to implement the character-oriented operations. This approach is better because it encapsulates the complexity of splitting and merging within the text class, which reduces the overall complexity of the system.</p><h2 id="_8-2-example-configuration-parameters" tabindex="-1"><a class="header-anchor" href="#_8-2-example-configuration-parameters" aria-hidden="true">#</a> 8.2 Example: configuration parameters</h2><p>Configuration parameters are an example of moving complexity upwards instead of down. Rather than determining a particular behavior internally, a class can export a few parameters that control its behavior, such as the size of a cache or the number of times to retry a request before giving up. Users of the class must then specify appropriate values for the parameters. Configuration parameters have become very popular in systems today; some systems have hundreds of them.</p><p>Advocates argue that configuration parameters are good because they allow users to tune the system for their particular requirements and workloads. In some situations it is hard for low-level infrastructure code to know the best policy to apply, whereas users are much more familiar with their domains. For instance, a user might know that some requests are more time-critical than others, so it makes sense for the user to specify a higher priority for those requests. In situations like this, configuration parameters can result in better performance across a broader variety of domains.</p><p>However, configuration parameters also provide an easy excuse to avoid dealing with important issues and pass them on to someone else. In many cases, it’s difficult or impossible for users or administrators to determine the right values for the parameters. In other cases, the right values could have been determined automatically with a little extra work in the system implementation. Consider a network protocol that must deal with lost packets. If it sends a request but doesn’t receive a response within a certain time period, it resends the request. One way to determine the retry interval is to introduce a configuration parameter. However, the transport protocol could compute a reasonable value on its own by measuring the response time for requests that succeed and then using a multiple of this for the retry interval. This approach pulls complexity downward and saves users from having to figure out the right retry interval. It has the additional advantage of computing the retry interval dynamically, so it will adjust automatically if operating conditions change. In contrast, configuration parameters can easily become out of date.</p><p>Thus, you should avoid configuration parameters as much as possible. Before exporting a configuration parameter, ask yourself: “will users (or higher-level modules) be able to determine a better value than we can determine here?” When you do create configuration parameters, see if you can compute reasonable defaults automatically, so users will only need to provide values under exceptional conditions. Ideally, each module should solve a problem completely; configuration parameters result in an incomplete solution, which adds to system complexity.</p><h2 id="_8-3-taking-it-too-far" tabindex="-1"><a class="header-anchor" href="#_8-3-taking-it-too-far" aria-hidden="true">#</a> 8.3 Taking it too far</h2><p>Use discretion when pulling complexity downward; this is an idea that can easily be overdone. An extreme approach would be to pull all of the functionality of the entire application down into a single class, which clearly doesn’t make sense. Pulling complexity down makes the most sense if (a) the complexity being pulled down is closely related to the class’s existing functionality, (b) pulling the complexity down will result in many simplifications elsewhere in the application, and (c) pulling the complexity down simplifies the class’s interface. Remember that the goal is to minimize overall system complexity.</p><p>Chapter 6 described how some students defined methods in the text class that reflected the user interface, such as a method that implements the functionality of the backspace key. It might seem that this is good, since it pulls complexity downward. However, adding knowledge of the user interface to the text class doesn’t simplify higher-level code very much, and the user-interface knowledge doesn’t relate to the core functions of the text class. In this case, pulling complexity down just resulted in information leakage.</p><h2 id="_8-4-conclusion" tabindex="-1"><a class="header-anchor" href="#_8-4-conclusion" aria-hidden="true">#</a> 8.4 Conclusion</h2><p>When developing a module, look for opportunities to take a little bit of extra suffering upon yourself in order to reduce the suffering of your users.</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/A-Philosophy-of-Software-Design-zh/en/ch07.html" class="" aria-label="Chapter 7 Different Layer, Different Abstraction"><!--[--><!--]--> Chapter 7 Different Layer, Different Abstraction <!--[--><!--]--></a></span><span class="next"><a href="/A-Philosophy-of-Software-Design-zh/en/ch09.html" class="" aria-label="Chapter 9 Better Together Or Better Apart?"><!--[--><!--]--> Chapter 9 Better Together Or Better Apart? <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/A-Philosophy-of-Software-Design-zh/assets/app.466a0dd3.js" defer></script>
  </body>
</html>
